/**
 * ServiceNow Webhook Endpoint
 * Handles incoming case classification requests from ServiceNow
 */

import { createHmac } from 'crypto';
import { CaseClassificationRepository } from '../lib/db/repositories/case-classification-repository';
import { getCaseClassifier } from '../lib/services/case-classifier';
import { ServiceNowClient } from '../lib/tools/servicenow';
import { formatWorkNote } from '../lib/services/work-note-formatter';

// Initialize services
const caseClassificationRepository = new CaseClassificationRepository();
const caseClassifier = getCaseClassifier();
const servicenow = new ServiceNowClient();

// Configuration
const WEBHOOK_SECRET = process.env.SERVICENOW_WEBHOOK_SECRET;
const ENABLE_CLASSIFICATION = process.env.ENABLE_CASE_CLASSIFICATION === 'true';
const WRITE_WORK_NOTES = process.env.CASE_CLASSIFICATION_WRITE_NOTES === 'true';
const MAX_RETRIES = parseInt(process.env.CASE_CLASSIFICATION_MAX_RETRIES || '3');

// Cache for duplicate detection (simple in-memory cache)
const duplicateCache = new Map<string, { timestamp: number; processed: boolean }>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Validate webhook signature
 */
function validateSignature(payload: string, signature: string): boolean {
  if (!WEBHOOK_SECRET) {
    console.warn('[Webhook] No webhook secret configured, skipping signature validation');
    return true;
  }

  const expectedSignature = createHmac('sha256', WEBHOOK_SECRET)
    .update(payload)
    .digest('hex');

  return signature === expectedSignature;
}

/**
 * Check for duplicate requests
 */
function isDuplicate(caseId: string): boolean {
  const cached = duplicateCache.get(caseId);
  if (!cached) return false;

  const now = Date.now();
  if (now - cached.timestamp > CACHE_TTL) {
    duplicateCache.delete(caseId);
    return false;
  }

  return cached.processed;
}

/**
 * Mark request as processed
 */
function markAsProcessed(caseId: string): void {
  duplicateCache.set(caseId, {
    timestamp: Date.now(),
    processed: true
  });
}

/**
 * Clean old cache entries
 */
function cleanCache(): void {
  const now = Date.now();
  for (const [key, value] of duplicateCache.entries()) {
    if (now - value.timestamp > CACHE_TTL) {
      duplicateCache.delete(key);
    }
  }
}

/**
 * Extract case information from webhook payload
 */
function extractCaseInfo(payload: any) {
  return {
    caseId: payload.sys_id || payload.case_id,
    caseNumber: payload.number || payload.case_number,
    shortDescription: payload.short_description || payload.description || '',
    description: payload.description || payload.comments || '',
    assignmentGroup: payload.assignment_group || '',
    assignedTo: payload.assigned_to || '',
    urgency: payload.urgency || '',
    impact: payload.impact || '',
    configurationItem: payload.configuration_item || payload.cmdb_ci || '',
    caller: payload.caller_id || payload.opened_by || '',
    category: payload.category || '',
    subcategory: payload.subcategory || '',
    businessService: payload.business_service || '',
    contactType: payload.contact_type || '',
    state: payload.state || ''
  };
}

/**
 * Write work note to ServiceNow
 */
async function writeWorkNote(caseId: string, workNote: string): Promise<boolean> {
  if (!WRITE_WORK_NOTES) {
    console.info('[Webhook] Work note writing disabled, skipping ServiceNow update');
    return true;
  }

  try {
    await servicenow.updateCase(caseId, {
      work_notes: workNote,
      comments: ''
    });
    
    console.info(`[Webhook] Work note written to case ${caseId}`);
    return true;
  } catch (error) {
    console.error(`[Webhook] Failed to write work note to case ${caseId}:`, error);
    return false;
  }
}

/**
 * Main webhook handler
 */
export async function POST(request: Request) {
  const startTime = Date.now();
  
  try {
    // Check if classification is enabled
    if (!ENABLE_CLASSIFICATION) {
      return Response.json(
        { error: 'Case classification is disabled' },
        { status: 503 }
      );
    }

    // Get request body and signature
    const payload = await request.text();
    const signature = request.headers.get('x-servicenow-signature') || 
                     request.headers.get('signature') || '';

    // Validate signature
    if (!validateSignature(payload, signature)) {
      console.warn('Invalid webhook signature received');
      return Response.json(
        { error: 'Invalid signature' },
        { status: 401 }
      );
    }

    // Parse payload
    let webhookData;
    try {
      webhookData = JSON.parse(payload);
    } catch (error) {
      console.error('Failed to parse webhook payload:', error);
      return Response.json(
        { error: 'Invalid JSON payload' },
        { status: 400 }
      );
    }

    // Extract case information
    const caseInfo = extractCaseInfo(webhookData);
    
    if (!caseInfo.caseId) {
      console.error('No case ID found in webhook payload');
      return Response.json(
        { error: 'Missing case ID' },
        { status: 400 }
      );
    }

    // Check for duplicates
    if (isDuplicate(caseInfo.caseId)) {
      console.info(`Duplicate request for case ${caseInfo.caseId}, skipping`);
      return Response.json(
        { message: 'Duplicate request ignored' },
        { status: 200 }
      );
    }

    // Clean old cache entries
    cleanCache();

    // Record inbound payload
    await caseClassificationRepository.saveInboundPayload({
      caseNumber: caseInfo.caseNumber,
      caseSysId: caseInfo.caseId,
      rawPayload: webhookData,
      routingContext: {
        assignmentGroup: caseInfo.assignmentGroup,
        assignedTo: caseInfo.assignedTo,
        category: caseInfo.category,
        subcategory: caseInfo.subcategory,
        priority: caseInfo.urgency,
        state: caseInfo.state
      },
      processed: false,
      processingError: null,
      workflowId: null,
      createdAt: new Date(),
      processedAt: null
    });

    console.info(`[Webhook] Processing case ${caseInfo.caseNumber} (${caseInfo.caseId})`);

    // Perform classification with retry logic
    let classificationResult = null;
    let lastError = null;
    
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        classificationResult = await caseClassifier.classifyCaseEnhanced({
          case_number: caseInfo.caseNumber,
          sys_id: caseInfo.caseId,
          short_description: caseInfo.shortDescription,
          description: caseInfo.description,
          assignment_group: caseInfo.assignmentGroup,
          priority: caseInfo.urgency,
          urgency: caseInfo.urgency,
          state: caseInfo.state
        });

        if (classificationResult) {
          break;
        }
      } catch (error) {
        lastError = error;
        console.warn(`[Webhook] Classification attempt ${attempt} failed for case ${caseInfo.caseId}:`, error);
        
        if (attempt < MAX_RETRIES) {
          // Exponential backoff
          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
        }
      }
    }

    if (!classificationResult) {
      console.error(`[Webhook] All classification attempts failed for case ${caseInfo.caseId}:`, lastError);
      
      return Response.json(
        { error: 'Classification failed after retries' },
        { status: 500 }
      );
    }

    // Record classification result
    await caseClassificationRepository.saveClassificationResult({
      caseNumber: caseInfo.caseNumber,
      workflowId: 'webhook',
      classificationJson: classificationResult,
      tokenUsage: {
        promptTokens: classificationResult.token_usage_input || 0,
        completionTokens: classificationResult.token_usage_output || 0,
        totalTokens: classificationResult.total_tokens || 0
      },
      cost: 0, // Cost calculation not implemented yet
      provider: classificationResult.llm_provider || 'openai',
      model: classificationResult.model_used || 'gpt-4',
      processingTimeMs: Date.now() - startTime,
      servicenowUpdated: false,
      entitiesCount: classificationResult.technical_entities ? 
        Object.values(classificationResult.technical_entities).flat().length : 0,
      similarCasesCount: classificationResult.similar_cases?.length || 0,
      kbArticlesCount: classificationResult.kb_articles?.length || 0,
      businessIntelligenceDetected: !!classificationResult.business_intelligence,
      confidenceScore: classificationResult.confidence_score || 0,
      retryCount: 1,
      createdAt: new Date()
    });

    // Record discovered entities
    if (classificationResult.technical_entities) {
      const entities = classificationResult.technical_entities;
      const discoveredEntities: any[] = [];
      
      for (const ip of entities.ip_addresses || []) {
        discoveredEntities.push({
          caseNumber: caseInfo.caseNumber,
          entityType: 'ip_address',
          entityValue: ip,
          confidence: 0.9,
          source: 'regex_extraction',
          metadata: { pattern: 'ip_address' },
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }

      for (const system of entities.systems || []) {
        discoveredEntities.push({
          caseNumber: caseInfo.caseNumber,
          entityType: 'system',
          entityValue: system,
          confidence: 0.8,
          source: 'regex_extraction',
          metadata: { pattern: 'hostname' },
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }

      for (const user of entities.users || []) {
        discoveredEntities.push({
          caseNumber: caseInfo.caseNumber,
          entityType: 'user',
          entityValue: user,
          confidence: 0.8,
          source: 'regex_extraction',
          metadata: { pattern: 'email_or_username' },
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }

      for (const error of entities.error_codes || []) {
        discoveredEntities.push({
          caseNumber: caseInfo.caseNumber,
          entityType: 'error_code',
          entityValue: error,
          confidence: 0.9,
          source: 'regex_extraction',
          metadata: { pattern: 'error_code' },
          createdAt: new Date(),
          updatedAt: new Date()
        });
      }

      if (discoveredEntities.length > 0) {
        await caseClassificationRepository.saveDiscoveredEntities(discoveredEntities);
      }
    }

    // Format and write work note
    // Convert the classification result to match the expected format
    const formattedClassification = {
      category: classificationResult.category,
      subcategory: classificationResult.subcategory,
      confidence_score: classificationResult.confidence_score,
      reasoning: classificationResult.reasoning,
      keywords: classificationResult.keywords,
      quick_summary: classificationResult.quick_summary,
      immediate_next_steps: classificationResult.immediate_next_steps,
      urgency_level: classificationResult.urgency_level,
      business_intelligence: classificationResult.business_intelligence ? {
        project_scope_detected: classificationResult.business_intelligence.project_scope_detected,
        project_scope_reason: classificationResult.business_intelligence.project_scope_reason,
        client_technology: classificationResult.business_intelligence.client_technology,
        client_technology_context: classificationResult.business_intelligence.client_technology_context,
        related_entities: classificationResult.business_intelligence.related_entities,
        outside_service_hours: classificationResult.business_intelligence.outside_service_hours,
        service_hours_note: classificationResult.business_intelligence.service_hours_note,
        executive_visibility: classificationResult.business_intelligence.executive_visibility || false,
        executive_visibility_reason: classificationResult.business_intelligence.executive_visibility_reason,
        compliance_impact: classificationResult.business_intelligence.compliance_impact || false,
        compliance_impact_reason: classificationResult.business_intelligence.compliance_impact_reason,
        financial_impact: classificationResult.business_intelligence.financial_impact || false,
        financial_impact_reason: classificationResult.business_intelligence.financial_impact_reason
      } : undefined,
      technical_entities: classificationResult.technical_entities,
      similar_cases: classificationResult.similar_cases,
      kb_articles: classificationResult.kb_articles
    };
    
    const workNote = formatWorkNote(formattedClassification);
    
    const workNoteWritten = await writeWorkNote(caseInfo.caseId, workNote);

    // Mark inbound payload as processed
    const unprocessedPayload = await caseClassificationRepository.getUnprocessedPayload(caseInfo.caseNumber);
    if (unprocessedPayload) {
      await caseClassificationRepository.markPayloadAsProcessed(
        unprocessedPayload.id,
        'webhook',
        undefined
      );
    }

    // Mark as processed to prevent duplicates
    markAsProcessed(caseInfo.caseId);

    const processingTime = Date.now() - startTime;
    
    console.info(
      `[Webhook] Case ${caseInfo.caseNumber} classified as ${classificationResult.category}` +
      `${classificationResult.subcategory ? ` > ${classificationResult.subcategory}` : ''}` +
      ` (${classificationResult.confidence_score ? Math.round(classificationResult.confidence_score * 100) : 0}% confidence)` +
      ` in ${processingTime}ms`
    );

    return Response.json({
      success: true,
      caseId: caseInfo.caseId,
      caseNumber: caseInfo.caseNumber,
      classification: {
        category: classificationResult.category,
        subcategory: classificationResult.subcategory,
        confidenceScore: classificationResult.confidence_score,
        urgencyLevel: classificationResult.urgency_level
      },
      processingTimeMs: processingTime,
      workNoteWritten
    });

  } catch (error) {
    console.error('Webhook processing failed:', error);
    
    return Response.json(
      { 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * Health check endpoint
 */
export async function GET() {
  return Response.json({
    status: 'healthy',
    classificationEnabled: ENABLE_CLASSIFICATION,
    workNoteWritingEnabled: WRITE_WORK_NOTES,
    maxRetries: MAX_RETRIES,
    timestamp: new Date().toISOString()
  });
}